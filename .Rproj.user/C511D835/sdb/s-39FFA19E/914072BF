{
    "collab_server" : "",
    "contents" : "######################################\n# Toolbox with basic auxiliary functions used throughout the package including:\n# - checking functions\n# - matrix and data frame functions\n# - decay functions\n# - residual sum of squares functions for fitting decay\n# - interpolation functions\n######################################\n\n# Check if activity patterns are well defined and return the time series vector\ndefine_activity = function(input_pattern) {\n    if (length(input_pattern) == 1) {\n        activity_pattern = activity_patterns[which(activity_patterns$id ==\n                                                       input_pattern), \"value\"]\n    } else {\n        assertVector(input_pattern)\n        assertNumeric(input_pattern, lower = 0, upper = 1, any.missing = FALSE)\n        activity_pattern = input_pattern\n    }\n\n    return(activity_pattern)\n}\n\n\n\n##### Matrix and data frame functions #####\nrep.row = function(x,n){\n    return(matrix(rep(x,each=n),nrow=n))\n}\n\nrep.col<-function(x,n){\n    matrix(rep(x,each=n), ncol=n, byrow=TRUE)\n}\n\nsplit_tibble = function(tibble, column) {\n    tibble %>% split(., .[,column])\n}\n\n# Converts a data frame to a list of its rows with attribute names\n# corresponding to the first column\nget_list_from_table = function(df) {\n    df.list = setNames(split(df[,-1], seq(nrow(df)), drop = TRUE), df[,1])\n    return(df.list)\n}\n\n##### Decay functions #####\n# Average exponential decay\navg_expDecay = function(initialEffects, halflife, duration) {\n    integral = initialEffects * (halflife / log(2)) *\n        (1 - exp(-log(2) * duration / halflife))\n    averageEffect = integral / duration\n    return(averageEffect)\n}\n\n# Functions for calculating effect decays\nWeibull_function = function(time, p) {\n    return(exp( -(time/p$L)^p$k * log(2)))\n}\n\nstep_function = function(time, p){\n    output = ifelse(time >= p$L, 0, 1)\n    return(output)\n}\n\nlinear_function = function(time, p){\n    return(1 - time/p$L)\n}\n\nexponential_function = function(time, p){\n    return(exp(-time/p$L * log(2)))\n}\n\nhill_function = function(time, p){\n    return(1 / (1 + (time/p$L)^p$k))\n}\n\nsmoothcompact_function = function(time, p){\n    output = (1 - (time>=p$L)) * exp((1 - (time>=p$L)) *\n                                         (p$k - p$k/(1 - (time/p$L)^2)))\n    return(output)\n}\n\nparabolic_growth_function = function(time, p){\n    return(p$a*time + p$b*time^2)\n}\n\nlogit = function(x){\n    return(log(x/(1-x)))\n}\n\nilogit = function(x){\n    return(exp(x)/(1+exp(x)))\n}\n\n# Generic exponential decay function definition:\n# par[1] = initialEffect, par[2] = halflife\nexponential_decay = function(par, p, num_p){\n    time = (p - 0.5)*P_DURATION/num_p\n    effect = par[1] * exponential_function(time, list(L = par[2]))\n    return(effect)\n}\n\n# Generic Weibull decay function definition:\n# par[1] = initialEffect, par[2] = halflife,\n# par[3] = exponent\nweibull_decay = function(par, p, num_p){\n    time = (p-0.5)*P_DURATION/num_p\n    effect = par[1] * Weibull_function(time=time, list(L=par[2], k=par[3]))\n    return(effect)\n}\n# Generic Hill decay function definition:\n# par[1] = initialEffect, par[2] = halflife,\n# par[3] = exponent\nhill_decay <- function(par, p, num_p){\n    time = (p-0.5)*P_DURATION/num_p\n    effect = par[1] * hill_function(time=time, list(L=par[2], k=par[3]))\n    return(effect)\n}\n\n# Generic step decay function definition:\n# par[1] = initialEffect, par[2] = time to full decay\nstep_decay = function(par, p, num_p){\n    time = (p-0.5)*P_DURATION/num_p\n    effect = par[1] * step_function(time=time, list(L=par[2]))\n    return(effect)\n}\n\n# Generic linear decay function definition:\n# par[1] = initialEffect, par[2] = time to full decay,\nlinear_decay = function(par, p, num_p){\n    time = (p-0.5)*P_DURATION/num_p\n    effect = par[1] * linear_function(time=time, list(L=par[2]))\n    return(effect)\n}\n\n# Generic smooth-compact decay function definition:\n# par[1] = initialEffect, par[2] = time to full decay,\n# par[3] = exponent\nsmoothcompact_decay = function(par, p, num_p){\n    time = (p-0.5)*P_DURATION/num_p\n    effect = par[1] * smoothcompact_function(time=time, list(L=par[2], k=par[3]))\n    return(effect)\n}\n\n# Definitions of the residual sum of squares functions to be optimized\nRSS_exponential_decay = function(data, par){\n    with(data, sum((exponential_decay(par, points, nrow(data)) - values)^2))\n}\n\nRSS_weibull_decay = function(data, par) {\n    with(data, sum((weibull_decay(par, points, nrow(data)) - values)^2))\n}\n\nRSS_hill_decay = function(data, par) {\n    with(data, sum((hill_decay(par, points, nrow(data)) - values)^2))\n}\n\nRSS_step_decay = function(data, par) {\n    with(data, sum((step_decay(par, points, nrow(data)) - values)^2))\n}\n\nRSS_linear_decay = function(data, par) {\n    with(data, sum((linear_decay(par, points, nrow(data)) - values)^2))\n}\n\nRSS_smoothcompact_decay = function(data, par) {\n    with(data, sum((smoothcompact_decay(par, points, nrow(data)) - values)^2))\n}\n\n\n# Generic function for calculating decay over a set of interpolation points\n# given a specified decay function (exponential, Weibull, ...)\n# Suggestion: approxfun\ninterp_decay = function(decay_f, decay_p, num_points) {\n    time = (1:num_points-0.5)*decay_p$duration/num_points\n    interp_effect = do.call(decay_f, list(time = time, p = decay_p))\n    return(decay_p$initialEffect * interp_effect)\n}\n\n# Spline interpolation\nspline_interpolation = function(yvar, semester, nips, duration) {\n    required_data = data.frame(semester)\n    required_data$net_age = (semester - 0.5)*0.5\n    required_data$yvar = yvar\n    net_age = seq(1:nips)*duration/nips\n    prediction_points = data.frame(net_age)\n    lm2 = lm(yvar ~ bs(net_age), data = required_data)\n    prediction = predict(lm2, data.frame(prediction_points))\n    return(prediction)\n}\n\n# Fit 5 types of decay curves to intervention effects interpolation points\n# and estimate their parameters as well the best fit to build a GVI\nget_best_decay_fit = function(values, duration, param_name, plot_flag) {\n\n    # Build the dataframe with the intervention effects at interpolation points\n    tab=NULL\n    num_p = length(values)\n    tab$points = c(1:num_p)\n    # Convert the points to fit in the overall duration of the intervention\n    tab$time = (tab$points-0.5)*duration/num_p\n    tab$values = values\n    tab = as.data.frame(tab)\n\n    # Build the dataframe with the raw values at interpolation points\n    data_tab = cbind.data.frame(\"raw data\", 1:nrow(tab), tab$values)\n    colnames(data_tab) = c(\"decay_function\", \"time\", \"value\")\n\n    # Initialize variables\n    P_DURATION <<- duration\n    values_tab = NULL\n    best_fit = NULL\n    best_fit$decay = \"\"\n    best_fit$RSS = 100000\n    best_fit$params = NULL\n\n    # Fit the different decay types and find the best fit:\n    tryCatch(\n        expr = {\n            nls_control = list(maxiter = 100)\n            exponential_fit = nlsLM(values ~ a*exp(-time/L*log(2)),\n                                    data = tab, start = list(a = tab$values[1],\n                                                             L = duration))\n            exponential_fit$name = \"exponential\"\n            weibull_fit = nlsLM(values ~ a*exp(-(time/L)^k * log(2)),\n                                data = tab, start = list(a = tab$values[1],\n                                                         L = duration, k = 1))\n            weibull_fit$name = \"Weibull\"\n            hill_fit = nlsLM(values ~ a/(1+(time/L)^k),\n                             data = tab, start = list(a = tab$values[1],\n                                                      L = duration, k = 1))\n            hill_fit$name = \"Hill\"\n            linear_fit = nlsLM(values ~ a*(1-time/L), data = tab,\n                               start = list(a = tab$values[1], L = duration))\n            linear_fit$name = \"linear\"\n            smoothcompact_fit = nlsLM(values ~ a*(c(1)-(time>=L))*\n                                          exp((c(1)-(time>=L))*k*\n                                                  (c(1)-1/(1-(time/L)^2))),\n                                      data = tab,\n                                      start = list(a = tab$values[1],\n                                                   k = 1, L = duration),\n                                      control = nls_control)\n            smoothcompact_fit$name = \"smooth-compact\"\n            # Concatenate all the fits so far\n            fit_list = list(exponential_fit = exponential_fit,\n                            weibull_fit = weibull_fit,\n                            hill_fit = hill_fit, linear_f = linear_fit,\n                            smoothcompact_fit = smoothcompact_fit)\n        },\n        error = function(e){\n            message(\"The following error occurred during fitting:\")\n            print(e)\n        }\n    )\n\n    # Find the best fit so far and obtain all the fitted curves\n    for (fit_obj in fit_list) {\n        if (!is.null(fit_obj)) {\n            # extract the residual sum of squares\n            fit_obj$RSS = fit_obj$m$deviance()\n            if (fit_obj$RSS < best_fit$RSS) {\n                best_fit$RSS = fit_obj$RSS\n                best_fit$decay = fit_obj$name\n                best_fit$params = fit_obj$m$getPars()\n            }\n            # get the fitted values\n            pred = fit_obj$m$predict()\n            # construct the data table with all the fits resuts (for plotting)\n            values_decay = cbind.data.frame(fit_obj$name, 1:nrow(tab),\n                                            pred, tab$values, fit_obj$RSS)\n            colnames(values_decay) = c(\"decay_function\", \"time\", \"value\",\n                                       \"initial_value\", \"RSS\")\n            values_tab = rbind.data.frame(values_tab, values_decay)\n        }\n    }\n\n    # For the step decay:\n    L_step = which.max(cumsum(tab$values)^2/c(1:nrow(tab)))\n    pred = do.call(\"step_decay\", list(par = c(mean(tab$values[1:L_step]),\n                                              L_step*P_DURATION/num_p),\n                                      p = 1:nrow(tab), nrow(tab)))\n\n    RSS = sum((pred - tab$values)^2)\n    # construct the data table with all the fits resuts (for plotting)\n    values_decay = cbind.data.frame(\"step\", 1:nrow(tab), pred,\n                                    tab$values, RSS)\n    colnames(values_decay) = c(\"decay_function\", \"time\", \"value\",\n                               \"initial_value\", \"RSS\")\n    values_tab = rbind.data.frame(values_tab, values_decay)\n\n    # For the constant decay:\n    pred = rep(mean(tab$values), nrow(tab))\n    RSS = sum((pred - tab$values)^2)\n    # construct the data table with all the fits resuts (for plotting)\n    values_decay = cbind.data.frame(\"constant\", 1:nrow(tab), pred,\n                                    tab$values, RSS)\n    colnames(values_decay) = c(\"decay_function\", \"time\", \"value\",\n                               \"initial_value\", \"RSS\")\n    values_tab = rbind.data.frame(values_tab, values_decay)\n\n    if (plot_flag) {\n        # Plot the fitted decays\n        p = plot_fits(data_tab, values_tab,\n                      paste(\"\\nFitting \", param_name,\n                            \"\\nBest fit:\", best_fit$decay))\n        plot(p)\n\n        # Print the best fit\n        print(\"Best decay fit:\")\n        print(best_fit)\n    }\n\n    return(best_fit)\n}\n\n# Prepare snippet for GVI intervention in the base xml file\nprepare_GVI_snippet = function(species, best_fit, param_name, id,\n                               GVI_file, f_append) {\n    func = paste(best_fit$decay)\n    init_effect = best_fit$params[1]\n    L = best_fit$params[2]\n    if(best_fit$decay %in% c(\"weibull\", \"hill\", \"smoothcompact\")) {\n        k = paste(' k=\"',  best_fit$params[3], '\"', sep=\"\")\n    } else {\n        k = ''\n    }\n    init_effect_d = init_effect * (param_name == \"deterrency\")\n    init_effect_pre = init_effect * (param_name == \"preprandial\")\n    init_effect_post = init_effect * (param_name == \"postprandial\")\n\n    # Construct the snippet\n    GVI_snippet = paste0('<GVI name=\"GVI ', id, '\" id=\"GVI_', id ,'_1\">\n    <decay L=\"', L, '\" function=\"', func, '\"', k, '/>\n    <anophelesParams mosquito=\"', species, '\" propActive=\"1\">\n    <deterrency value=\"', init_effect_d, '\"/>\n    <preprandialKillingEffect value=\"', init_effect_pre, '\"/>\n    <postprandialKillingEffect value=\"', init_effect_post, '\"/>\n    </anophelesParams>\n    </GVI>\\n')\n\n    # Write the snippet to the output file\n    cat(GVI_snippet, sep= \"\", file = GVI_file, append = f_append)\n    return(GVI_snippet)\n}\n\n",
    "created" : 1634601728792.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4079968251",
    "id" : "914072BF",
    "lastKnownWriteTime" : 1634602274,
    "last_content_update" : 1634602274719,
    "path" : "~/Documents/GitRepos/anophelesmodel2/dev_AnophelesModel/AnophelesModel/R/internal_aux_functions.R",
    "project_path" : "R/internal_aux_functions.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}